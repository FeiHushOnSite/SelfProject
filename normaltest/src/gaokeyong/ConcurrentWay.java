package gaokeyong;


import java.util.LinkedList;

/**
 * 开发高并发系统 三种方法： 缓存、降级、限流
 * 使用缓存可以提升体统访问速度，提高并发访问量，也是保护数据库、保护系统的方式
 *
 * 降级： 是当服务器访问量巨大压力大的情况下，根据当前业务情况以及流量对一些服务和页面有策略的降级。
 * 根据服务范围： 可以砍掉某个功能，也可以砍掉某些模块
 *
 * 限流： 也是服务降级的一种， 限流就是限制系统的输入和输出流量已达到保护系统的目的。一般来说系统的吞吐量是可以被测算的，为了保证系统
 * 的稳定运行，一旦达到的需要限制的阈值，就需要限制流量并采取限流。 如：延迟处理，拒绝处理，或者部分拒绝处理等等。
 *
 * 限流的算法： 计数器，漏桶和令牌桶算法。
 *
 */
public class ConcurrentWay {

    /**
     * 计数器  简单粗暴的算法，比如某个服务最多只能每秒处理100个请求。我们可以设置一个1秒钟的滑动窗口，窗口中有10个格子，
     * 每个格子100毫秒，每100毫秒移动一次，每次移动都需要记录当前的服务请求的次数。内存中需要保存10次的次数。可以用数据结构LinkedList实现
     * 格子每次移动的时候判断一次，当前访问次数和LinkedList中最后一个相差是否超过100。如果超过就需要限流了。
     * Obviously, 当滑动窗口的格子划分越多，那么滑动窗口的滚动就越平滑，限流的统计就会越精准。
     */

    //服务访问次数，可以放在Redis中，实现分布式系统的访问计数
    Long counter = 9L;
    //使用LinkedList来记录滑动窗口的10个格子
    LinkedList<Long> l1 = new LinkedList<Long>();
    public static void main(String[] args) {
        ConcurrentWay counter = new ConcurrentWay();

        try {
            counter.doCheck();
            throw new Exception("这有问题啊");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private void doCheck() throws Exception{
        while (true){
            l1.addLast(counter);
            if(l1.size() > 10){
                l1.removeFirst();
            }

            //比较最后一个和第一个，两者相差一秒
            if((l1.peekLast() - l1.peekFirst()) > 100){
                //To limit rate
            }
            Thread.sleep(100);
        }
    }

    /**
     * 漏桶算法 即leaky bucket是一种用来实现流量整形 （Traffic Shaping）和流量控制（Traffic Policing）
     * 主要概念： 一个固定容量的漏桶，按照常量固定速率流出水滴；
     * 如果桶是空的，则不需要流出水滴；
     * 可以以任意速率流入水滴到漏桶；
     * 如果流入水滴超出了桶的容量，则流入的水滴溢出了（被丢弃），而漏桶容量则是不变的。
     * 分布式环境中消息中间件或者Redis都是可选方案。
     */

    //---------------------------------------------------------------------------------------------------

    /**
     * 令牌桶算法
     * 是一个存放固定容量令牌（token）的桶，按照固定速率往桶里添加令牌
     * 1. 令牌将按照固定的速率被放入令牌桶中，比如每秒放10个。
     * 2. 桶中最多存放b个令牌，当桶满时，新添加的令牌被丢弃或拒绝。
     * 3. 当一个n字节大小的数据包到达时，将从桶中删除n个令牌，接着数据包被发送到网络上。
     * 4. 如果桶中的令牌不足n个，则不会删除令牌，且该数据包将被限流 (要么丢弃，要么缓冲区等待)。
     */



    //Guava

    public void test(){
        /**
         * 创建一个限流器，设置每秒放置的令牌数：2个，速率是每秒可以2个的消息。
         * 返回的RateLimiter对象可以保证1秒内不会给超过2个令牌，并且是固定速率的放置。达到平滑输出的效果。
         */
    }
}
